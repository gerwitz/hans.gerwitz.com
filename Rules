#!/usr/bin/env ruby

# A few helpful tips about the Rules file:
#
# * The string given to #compile and #route are matching patterns for
#   identifiers--not for paths. Therefore, you can’t match on extension.
#
# * The order of rules is important: for each item, only the first matching
#   rule is applied.
#
# * Item identifiers start and end with a slash (e.g. “/about/” for the file
#   “content/about.html”). To select all children, grandchildren, … of an
#   item, use the pattern “/about/*/”; “/about/*” will also select the parent,
#   because “*” matches zero or more characters.

preprocess do  
  # remove hidden items
  @items.delete_if { |i| i[:kind] == 'hidden' }

  # init "smart" archive hashes
  post_categories = Hash.new{|h, c| h[c] = []}
  post_years_months = Hash.new do |h, y|
    h[y] = Hash.new{|ms, m| ms[m] = []}
  end

  # set article metadata based on filesystem path, and build archive hashes
  @items.select { |i| i.identifier.start_with?('/articles/') and not i.binary? }.each do |post|
    post[:kind] ||= 'post'
    id_parts = post.identifier.split('/')
    # id_parts[1] is 'articles'
    post_years_months[id_parts[2]][id_parts[3]] << post
    post[:date] ||= id_parts[2..4].join('/')
    post[:slug] ||= id_parts[5]
    if (post[:categories] != nil)
      post[:categories].each do |cat|
        post_categories[cat.downcase] << post
      end
    end
  end

  # make RSS feed
  @items << Nanoc3::Item.new(
    "latest posts",
    {
      :posts => latest_posts(10)
    },
    "/feeds/rss/"
    # :checksum => something
  )
  # make uberfeed for Tapir
  @items << Nanoc3::Item.new(
    "Superfeed!",
    {
      :posts => sorted_posts
    },
    "/feeds/rss-all/"
    # :checksum => something
  )

  # make category pages
  # TODO: real checksum
  cat_hash = Hash.new
  post_categories.each_pair do |cat, posts|
    cat_id = "/archive/categories/#{cat}/"
    
    posts.sort_by! do |a|
      attribute_to_time(a[:date])
    end.reverse!

    existing_item_i = @items.index { |item| item.identifier == cat_id }
    if existing_item_i
      # print "Found content for #{cat_id}\n"
      category_item = @items[existing_item_i]
      category_item[:posts] = posts
    else
      category_item = Nanoc3::Item.new(
        "<!-- If #{cat} had content, it would be here. -->",
        {
          :title => "#{cat}",
          :posts => posts
        },
        cat_id
      )
      @items << category_item
    end
    print "Category #{category_item.identifier} has #{category_item[:posts].count} posts\n"
    cat_hash[cat_id] = category_item
  end
  
  # cats_summary = cat_hash.map do |cat,posts|
  #   cat + posts.map {|post| post.identifier}
  # end
  # print "\n\n cats_summary: #{cats_summary}\n\n"
  
  # make category list page
  @items << Nanoc3::Item.new(
    "Archive Categories", # not used
    {
      :title => "categories",
      :categories => cat_hash.values
    },
    "/archive/categories/"
    # :checksum => Digest::MD5.hexdigest( cats_summary )
  )
  
  # make year list page
  @items << Nanoc3::Item.new(
    "Archive Years", # not used
    {
      :title => "years",
      :months_by_year => post_years_months
    },
    "/archive/years/"
    # :checksum => Digest::MD5.hexdigest( months_summary )
  )
      
  print("Preprocess complete\n")
end





compile 'sitemap' do
  filter :erb
end

compile '/feeds/*' do
  filter :erb
  layout 'rss'
end

compile 'robots' do
  # unfiltered
end

compile 'htaccess' do
  # unfiltered
end

compile '/assets/*' do
  case item[:extension]
    when 'css'
#      filter :rainpress
    when 'js'
#      filter :jsmin
  end
end

compile '/archive/years/' do
  layout 'years'
  # filter :erubis
  layout 'site'
end


compile '/archive/categories/' do
  layout 'categories-index'
  # filter :erubis
  layout 'site'
end

compile '/archive/categories/*' do
  case item[:extension]
    when 'md'
      filter :kramdown
  end
  layout 'category'
  layout 'site'
end

compile '/' do
  filter :kramdown
  filter :typogruby
  layout 'home'
  filter :erb
  layout 'site'
end

compile '/search' do
  filter :kramdown
  layout 'site'
end

compile '/articles/*/', :rep => 'default' do
  unless item.binary? or item[:external]
    case item[:extension]
      when 'md'
        filter :kramdown
    end
    layout 'article'
    filter :erb
    layout 'site'
  end
end

# not yet used, but eventually we'll filter these for absolute links and use them in RSS
compile '/articles/*/', :rep => 'absolute' do
  unless item.binary? or item[:external]
    case item[:extension]
      when 'md'
        filter :kramdown
    end
  end
end

# all other pages
compile '*', :rep => 'default' do
  unless item.binary? or item[:external]
    case item[:extension]
      when 'md'
        filter :kramdown
    end
    layout 'page'
    # filter :erb
    layout 'site'
  end
end




route '/' do
  '/index.html'
end

route 'sitemap' do
  item.identifier.chop + '.xml'
end

route 'robots' do
  item.identifier.chop + '.txt'
end

route '/fonts/*' do 
  # from static data source, so they already have extension in identifier
  '/assets/' + item.identifier.chop
end

route '/assets/*' do
  item.identifier.chop + '.' + item[:extension]
end

route '/feeds/*' do
	item.identifier.chop + '.xml'
end

route 'htaccess' do
  '/.htaccess'
end

route '*/htaccess' do
  dir = item.identifier.chop
  dir[0,dir.rindex('/')] + '/.htaccess'
end

route '/articles/*/' do
  filelike_identifier(item).partition('/articles')[2]
end

# don't route these, they are only for feeds
route '/articles/*/', :rep => :absolute do
  nil
end

route '/categories/' do
  '/categories/index.html'
end

route '/categories/*/' do
  filelike_identifier(item)
end


route '*' do
  if item.binary?
    # Write item with identifier /foo/ to /foo.ext
    item.identifier.chop + '.' + item[:extension]
  else
    # Write item with identifier /foo/ to /foo.html
    item.identifier.chop + '.html'
  end
end

layout '*', :erb
